using System.Diagnostics.CodeAnalysis;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;

namespace WatcherEye.Core.Extensions;

public static class SyntaxTreeExtensions
{
	private const char DirectorySeparatorChar = '\\';
	private const char AltDirectorySeparatorChar = '/';
	private const char VolumeSeparatorChar = ':';
	private static readonly string[] AutoGeneratedStrings = new[] { "<autogenerated", "<auto-generated" };
	public static bool IsGenerated(this SyntaxTree syntaxTree)
	{
		return IsGeneratedCode(
			syntaxTree,
			isComment: trivia => trivia.IsKind(SyntaxKind.SingleLineCommentTrivia) || trivia.IsKind(SyntaxKind.MultiLineCommentTrivia),
			cancellationToken: CancellationToken.None);
	}

	private static bool IsGeneratedCode(
		SyntaxTree tree, Func<SyntaxTrivia, bool> isComment, CancellationToken cancellationToken)
	{
		return IsGeneratedCodeFile(tree.FilePath) ||
		       BeginsWithAutoGeneratedComment(tree, isComment, cancellationToken);
	}
	private static bool BeginsWithAutoGeneratedComment(
		SyntaxTree tree, Func<SyntaxTrivia, bool> isComment, CancellationToken cancellationToken)
	{
		var root = tree.GetRoot(cancellationToken);
		if (root.HasLeadingTrivia)
		{
			var leadingTrivia = root.GetLeadingTrivia();

			foreach (var trivia in leadingTrivia)
			{
				if (!isComment(trivia))
				{
					continue;
				}

				var text = trivia.ToString();

				// Check to see if the text of the comment contains an auto generated comment.
				foreach (var autoGenerated in AutoGeneratedStrings)
				{
					if (text.Contains(autoGenerated))
					{
						return true;
					}
				}
			}
		}

		return false;
	}

	private static bool IsGeneratedCodeFile([NotNullWhen(returnValue: true)] string? filePath)
	{
		if (!filePath.IsNullOrEmpty())
		{
			var fileName = GetFileName(filePath!);
			if (fileName!.StartsWith("TemporaryGeneratedFile_", StringComparison.OrdinalIgnoreCase))
			{
				return true;
			}

			var extension = GetExtension(fileName);
			if (!string.IsNullOrEmpty(extension))
			{
				var fileNameWithoutExtension = GetFileName(filePath!, includeExtension: false);
				if (fileNameWithoutExtension!.EndsWith(".designer", StringComparison.OrdinalIgnoreCase) ||
				    fileNameWithoutExtension.EndsWith(".generated", StringComparison.OrdinalIgnoreCase) ||
				    fileNameWithoutExtension.EndsWith(".g", StringComparison.OrdinalIgnoreCase) ||
				    fileNameWithoutExtension.EndsWith(".g.i", StringComparison.OrdinalIgnoreCase))
				{
					return true;
				}
			}
		}

		return false;
	}

	private static string? GetFileName(string path, bool includeExtension = true)
	{
		int fileNameStart = IndexOfFileName(path);
		var fileName = (fileNameStart <= 0) ? path : path!.Substring(fileNameStart);
		return includeExtension ? fileName : RemoveExtension(fileName);
	}
	
	private static int IndexOfFileName(string? path)
	{
		if (path == null)
		{
			return -1;
		}

		for (int i = path.Length - 1; i >= 0; i--)
		{
			char ch = path[i];
			if (ch is DirectorySeparatorChar or AltDirectorySeparatorChar or VolumeSeparatorChar)
			{
				return i + 1;
			}
		}
		return 0;
	}
	
	private static string? RemoveExtension(string? path)
	{
		if (path == null)
		{
			return null;
		}

		int index = IndexOfExtension(path);
		if (index >= 0)
		{
			return path.Substring(0, index);
		}

		// trim last ".", if present
		if (path.Length > 0 && path[^1] == '.')
		{
			return path.Substring(0, path.Length - 1);
		}

		return path;
	}
	
	private static int IndexOfExtension(string? path) =>
		path is null
			? -1
			: IndexOfExtension(path.AsSpan());
	
	private static int IndexOfExtension(ReadOnlySpan<char> path)
	{
		int length = path.Length;
		int i = length;

		while (--i >= 0)
		{
			char c = path[i];
			if (c == '.')
			{
				if (i != length - 1)
				{
					return i;
				}

				return -1;
			}

			if (c is DirectorySeparatorChar or AltDirectorySeparatorChar or VolumeSeparatorChar)
			{
				break;
			}
		}

		return -1;
	}
	
	internal static string? GetExtension(string? path)
	{
		if (path == null)
		{
			return null;
		}

		int index = IndexOfExtension(path);
		return (index >= 0) ? path[index..] : string.Empty;
	}
}